# Задачу поиска максимального независимого множества в взвешенном графе можно сформулировать следующим образом:

# Пусть G = (V, E) - неориентированный граф, где V = {v1, v2, ..., vn} - множество вершин, а E - множество ребер. Каждая вершина vi имеет соответствующий вес wi. Требуется найти независимое множество вершин I ⊆ V, такое что сумма весов вершин в I максимальна, и для любых двух вершин vi, vj ∈ I не существует ребра (vi, vj) ∈ E.

# Математически эту задачу можно записать как задачу булевого программирования:

# Максимизировать:
# ∑(i=1 to n) wi * xi

# При ограничениях:
# xi + xj ≤ 1, для всех (i, j) ∈ E
# xi ∈ {0, 1}, для всех i = 1, 2, ..., n

# Где:
# - n - количество вершин в графе
# - wi - вес вершины vi
# - xi - переменная принимающая значение 1, если вершина vi включена в независимое множество, и 0 в противном случае
# - E - множество ребер графа

# Целевая функция ∑(i=1 to n) wi * xi представляет сумму весов всех выбранных вершин.

# Ограничение xi + xj ≤ 1 для всех (i, j) ∈ E гарантирует, что в независимое множество не включаются смежные вершины, так как если xi = 1 и xj = 1, то (i, j) ∉ E.

# Таким образом, задача сводится к нахождению бинарного вектора x = (x1, x2, ..., xn), максимизирующего целевую функцию при заданных ограничениях.

# Эта формулировка соответствует задаче поиска максимального независимого множества в взвешенном графе, где веса вершин представлены весами wi, а совместимость вершин определяется отсутствием ребра между ними в графе.

# Данная задача является NP-трудной, и ее точное решение для больших графов может быть вычислительно сложным. Поэтому на практике часто используются эвристические или приближенные алгоритмы для нахождения близкого к оптимальному решения за разумное время.
#------------------------------------------
# В этой реализации используется рекурсивный алгоритм поиска независимого множества с максимальной суммой весов (максимальное независимое множество в взвешенном графе).
# Основные шаги алгоритма:

# Функция are_compatible проверяет совместимость двух гипотез по матрице совместимости.
# Функция find_max_weight_independent_set реализует рекурсивный алгоритм поиска независимого множества.
# Внутри функции backtrack происходит рекурсивный перебор всех возможных комбинаций гипотез.
# При переборе учитываются две возможности для каждой гипотезы: включить ее в текущее решение или не включать.
# Если гипотеза включается, то проверяется ее совместимость со всеми остальными гипотезами и происходит рекурсивный вызов для следующих гипотез.
# Найденные решения (независимые множества) сохраняются в список solutions.
# После перебора всех комбинаций решения сортируются по убыванию суммы весов.
# Результаты выводятся в требуемом формате.

# Этот алгоритм имеет экспоненциальную временную сложность O(2^n), так как перебираются все возможные комбинации гипотез. Однако он гарантирует нахождение оптимального решения (максимального независимого множества с максимальной суммой весов).
# Следует отметить, что для больших размеров входных данных этот алгоритм может работать медленно, и в таких случаях могут потребоваться другие, более эффективные, алгоритмы или эвристические подходы.
# Входные данные

def load_data_from_file(file_path):
    with open(file_path, 'r') as file:
        lines = file.readlines()

    data = []
    for line in lines[:-1]:  # Пропускаем последнюю строку (weight)
        row = [int(x) for x in line.strip().split(',')]
        data.append(row)

    weight = [float(x) for x in lines[-1].strip().split(',')]

    return data, weight

# Пример использования
file_path = 'input_with_weights.csv'
THCompatibilityMatrix, weight = load_data_from_file(file_path)

# Функция для проверки совместимости двух гипотез
def are_compatible(i, j):
    return THCompatibilityMatrix[i][j] == 1

# Функция для поиска независимого множества с максимальной суммой весов
def find_max_weight_independent_set():
    n = len(weight)
    solutions = []

    # Функция для рекурсивного перебора
    def backtrack(idx, curr_soln, curr_weight):
        if idx == n:
            solutions.append((curr_soln.copy(), curr_weight))
            return

        # Включить текущую гипотезу
        curr_soln.append(idx)
        new_weight = curr_weight + weight[idx]
        for j in range(idx + 1, n):
            if are_compatible(idx, j):
                backtrack(j + 1, curr_soln, new_weight)
        curr_soln.pop()

        # Не включать текущую гипотезу
        backtrack(idx + 1, curr_soln, curr_weight)

    # Вызов рекурсивной функции для перебора
    backtrack(0, [], 0)

    # Сортировка решений по убыванию суммы весов
    solutions.sort(key=lambda x: x[1], reverse=True)

    return solutions

solutions = find_max_weight_independent_set()
# Вывод результатов
file_path = 'out.csv'

with open(file_path, 'w') as file:
    # Записываем заголовок
    header = ','.join([f"TH{i}" for i in range(1, len(THCompatibilityMatrix[0]) + 1)])
    file.write(f",{header},sum(w)\n")

    # Записываем строки с данными
    for i, (solution, sum_weights) in enumerate(solutions, start=1):
        solution_str = ','.join(['1' if j in solution else '0' for j in range(len(THCompatibilityMatrix))])
        file.write(f"GH{i},{solution_str},{sum_weights:.3f}\n")